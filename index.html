<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixelCraft - Professional Creative Studio</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- GifShot for Video to GIF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gifshot/0.3.2/gifshot.min.js"></script>

    <style>
        /* Custom Styles */
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        .checkered-bg {
            background-image: linear-gradient(45deg, #e2e8f0 25%, transparent 25%), 
                              linear-gradient(-45deg, #e2e8f0 25%, transparent 25%), 
                              linear-gradient(45deg, transparent 75%, #e2e8f0 75%), 
                              linear-gradient(-45deg, transparent 75%, #e2e8f0 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #7c3aed; /* violet-600 */
            cursor: pointer;
            margin-top: -6px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e2e8f0;
            border-radius: 2px;
        }

        /* Animations */
        @keyframes fadeInDown {
            from { opacity: 0; transform: translate(-50%, -10px); }
            to { opacity: 1; transform: translate(-50%, 0); }
        }
        .animate-fade-in-down {
            animation: fadeInDown 0.3s ease-out forwards;
        }
        
        /* Handles */
        .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #7c3aed;
            border: 2px solid white;
            border-radius: 50%;
            z-index: 20;
            transform: translate(-50%, -50%);
        }
        
        /* Font Sizes */
        .text-size-small { font-size: 14px; }
        .text-size-normal { font-size: 16px; }
        .text-size-large { font-size: 18px; }
    </style>
</head>
<body class="bg-slate-100 h-screen flex flex-col overflow-hidden text-size-normal" id="app-body">

    <!-- LANDING PAGE (Initial State) -->
    <div id="landing-page" class="flex-1 flex flex-col items-center justify-center p-4">
        <div class="flex justify-end w-full absolute top-0 p-4 gap-2">
            <button onclick="toggleLang()" class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-white border border-slate-200 text-sm font-medium text-slate-600 hover:bg-slate-50 transition-colors">
                <i data-lucide="globe" class="w-4 h-4"></i> <span id="lang-btn-text">English</span>
            </button>
        </div>

        <div class="max-w-xl w-full text-center space-y-8 -mt-16">
            <div class="space-y-2">
                <div class="flex justify-center mb-4">
                    <div class="w-20 h-20 bg-gradient-to-br from-violet-600 to-indigo-600 rounded-2xl flex items-center justify-center text-white shadow-xl shadow-indigo-200">
                        <i data-lucide="sparkles" class="w-10 h-10"></i>
                    </div>
                </div>
                <h1 class="text-4xl font-bold text-slate-900 tracking-tight" id="landing-title">PixelCraft</h1>
                <p class="text-slate-500 text-lg" id="landing-subtitle">Professional creative studio for your browser.</p>
            </div>
            
            <div class="relative group cursor-pointer" onclick="document.getElementById('file-upload').click()">
                <div class="absolute -inset-1 bg-gradient-to-r from-violet-600 to-indigo-600 rounded-2xl blur opacity-25 group-hover:opacity-50 transition duration-200"></div>
                <div class="relative bg-white rounded-xl p-12 border-2 border-dashed border-slate-300 hover:border-violet-500 transition-colors flex flex-col items-center justify-center space-y-4 shadow-sm">
                    <input type="file" id="file-upload" class="hidden" accept="image/*,video/*,.svg" onchange="handleUpload(event)">
                    <div class="w-16 h-16 bg-violet-50 text-violet-600 rounded-full flex items-center justify-center">
                        <i data-lucide="upload" class="w-8 h-8"></i>
                    </div>
                    <div class="text-center">
                        <p class="text-lg font-medium text-slate-700" id="landing-upload-title">Click or drag image/video</p>
                        <p class="text-sm text-slate-400 mt-1" id="landing-upload-desc">Supports PNG, JPG, WEBP, SVG, MP4</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- MAIN EDITOR (Hidden by default) -->
    <div id="editor-page" class="h-full flex flex-col hidden">
        <!-- HEADER -->
        <header class="h-16 bg-white border-b border-slate-200 flex items-center justify-between px-6 shrink-0 z-20 shadow-sm">
            <div class="flex items-center gap-2 font-bold text-xl text-slate-800">
                <div class="w-8 h-8 bg-gradient-to-br from-violet-600 to-indigo-600 rounded-lg flex items-center justify-center text-white shadow-sm">
                    <i data-lucide="sparkles" class="w-4 h-4"></i>
                </div>
                <span class="bg-clip-text text-transparent bg-gradient-to-r from-violet-700 to-indigo-700 font-extrabold tracking-tight" id="header-title">PixelCraft</span>
            </div>

            <div class="flex items-center gap-4">
                <button onclick="toggleFontSize()" class="flex items-center gap-1.5 px-3 py-1.5 rounded-lg bg-slate-50 text-[0.75em] font-medium text-slate-600 hover:bg-slate-100 transition-colors" title="Toggle Font Size">
                    <i data-lucide="type" class="w-3 h-3"></i> <span class="capitalize" id="font-size-label">Normal</span>
                </button>
                <button onclick="toggleLang()" class="flex items-center gap-1.5 px-3 py-1.5 rounded-lg bg-slate-50 text-[0.75em] font-medium text-slate-600 hover:bg-slate-100 transition-colors">
                    <i data-lucide="globe" class="w-3 h-3"></i> <span id="header-lang-text">EN/中</span>
                </button>
                <div class="h-6 w-px bg-slate-200 mx-2"></div>
                <div class="flex items-center gap-1 bg-slate-100 rounded-lg p-1">
                    <button onclick="adjustZoom(-0.1)" class="p-1.5 hover:bg-white rounded-md text-slate-600 transition-colors"><i data-lucide="zoom-out" class="w-4 h-4"></i></button>
                    <span id="zoom-level" class="text-[0.75em] font-medium w-12 text-center text-slate-600">100%</span>
                    <button onclick="adjustZoom(0.1)" class="p-1.5 hover:bg-white rounded-md text-slate-600 transition-colors"><i data-lucide="zoom-in" class="w-4 h-4"></i></button>
                </div>
                <div class="h-6 w-px bg-slate-200 mx-2"></div>
                <div id="history-controls" class="flex gap-2">
                    <button onclick="handleUndo()" id="btn-undo" class="flex items-center gap-2 px-3 py-1.5 rounded-lg text-[0.875em] font-medium text-slate-300 cursor-not-allowed"><i data-lucide="undo" class="w-4 h-4"></i> <span data-t="undo">Undo</span></button>
                    <button onclick="handleRedo()" id="btn-redo" class="flex items-center gap-2 px-3 py-1.5 rounded-lg text-[0.875em] font-medium text-slate-300 cursor-not-allowed"><i data-lucide="redo" class="w-4 h-4"></i> <span data-t="redo">Redo</span></button>
                </div>
                <button onclick="resetApp()" class="flex items-center gap-2 px-3 py-1.5 rounded-lg text-[0.875em] font-medium text-red-600 hover:bg-red-50 transition-colors">
                    <i data-lucide="trash-2" class="w-4 h-4"></i> <span class="hidden sm:inline" data-t="reset">Reset</span>
                </button>
            </div>
        </header>

        <div class="flex-1 flex overflow-hidden">
            <!-- LEFT TOOLBAR -->
            <div id="toolbar" class="w-20 bg-white border-r border-slate-200 flex flex-col items-center py-6 gap-4 shrink-0 z-10 shadow-[2px_0_10px_rgba(0,0,0,0.05)] overflow-y-auto">
                <!-- Tools injected by JS -->
            </div>

            <!-- CENTER CANVAS -->
            <div id="canvas-container" class="flex-1 relative bg-slate-50/50 overflow-hidden flex items-center justify-center p-0 checkered-bg select-none" onwheel="handleScrollZoom(event)">
                
                <!-- Notification -->
                <div id="notification" class="absolute top-4 left-1/2 -translate-x-1/2 z-50 bg-slate-800 text-white px-4 py-2 rounded-full text-[0.875em] font-medium shadow-lg hidden transition-opacity duration-300"></div>

                <div id="canvas-wrapper" class="relative shadow-2xl transition-transform duration-100 ease-out origin-center">
                    <canvas id="main-canvas" class="block bg-white cursor-default"></canvas>
                    <video id="main-video" class="block bg-black hidden" controls></video>
                    
                    <!-- Overlays Container -->
                    <div id="overlay-layer" class="absolute inset-0 pointer-events-none"></div>
                </div>
            </div>

            <!-- RIGHT SETTINGS PANEL -->
            <div id="settings-panel" class="w-80 bg-white border-l border-slate-200 p-6 flex flex-col shrink-0 animate-slide-in-right z-10 shadow-xl overflow-y-auto hidden">
                <!-- Dynamic Content -->
            </div>
        </div>
    </div>

    <!-- Hidden Input for Overlay Upload -->
    <input type="file" id="overlay-upload" class="hidden" accept="image/*" onchange="handleOverlayFile(event)">

    <script>
        /**
         * STATE & CONFIG
         */
        const state = {
            lang: 'en',
            fontSize: 'normal',
            imageSrc: null,
            videoSrc: null,
            history: [],
            historyIndex: -1,
            activeTool: null,
            zoom: 1,
            originalDims: { w: 0, h: 0 },
            currentDims: { w: 0, h: 0 },
            
            // Tool Configs
            crop: { rect: null, lockAspect: false },
            resize: { width: 0, height: 0, maintainAspect: true, scale: 100 },
            bgRemove: { tolerance: 20 },
            text: { text: 'Hello World', x: 0.5, y: 0.5, size: 50, color: '#ffffff' },
            overlay: { src: null, img: null, x: 0.5, y: 0.5, scale: 0.3 },
            gif: { duration: 2, generating: false },
            export: { name: 'edited-image', format: 'image/jpeg', quality: 0.9 },
            fileSizePreview: null
        };

        const TRANSLATIONS = {
            en: {
                appTitle: "PixelCraft", subtitle: "Professional creative studio for your browser.",
                uploadTitle: "Click or drag image/video", uploadDesc: "Supports PNG, JPG, WEBP, SVG, MP4",
                crop: "Crop", resize: "Resize", removeBg: "Remove BG", text: "Text", overlay: "Overlay", export: "Export", convert: "Convert",
                undo: "Undo", redo: "Redo", reset: "Reset",
                cropImage: "Crop Image", dragHandles: "Drag handles to crop.", free: "Free", original: "Original", applyCrop: "Apply Crop", lockAspect: "Lock Ratio", fitMax: "Fit Max",
                resizeImage: "Resize Image", percentage: "Percentage", width: "Width", height: "Height", applyResize: "Apply Resize", estSize: "Est. Size",
                removeBackground: "Remove Background", magicWand: "Magic Wand", magicWandDesc: "Click image to remove color.", autoRemove: "Auto Remove", outlineOnly: "Outline", tolerance: "Tolerance", done: "Done",
                addText: "Add Text", textInput: "Text Input", textColor: "Color", textSize: "Size", applyText: "Apply Text",
                addOverlay: "Add Overlay", uploadOverlay: "Upload Image", overlaySize: "Size", applyOverlay: "Apply Overlay", changeImage: "Change Image",
                videoToGif: "Video to GIF", gifDuration: "Duration (s)", createGif: "Create GIF", generating: "Generating...", videoFrame: "Video Frame", captureFrame: "Capture Frame",
                exportImage: "Export / Convert", fileName: "File Name", format: "Format", quality: "Quality", downloadImage: "Download File",
                imageCropped: "Image cropped!", imageResized: "Resized!", bgRemoved: "Background removed!", textAdded: "Text added!", overlayAdded: "Overlay added!", imageDownloaded: "Downloaded!"
            },
            zh: {
                appTitle: "像素工坊", subtitle: "為您的瀏覽器打造的專業創意工作室。",
                uploadTitle: "點擊或拖曳上傳圖片/影片", uploadDesc: "支援 PNG, JPG, WEBP, SVG, MP4",
                crop: "裁剪", resize: "調整大小", removeBg: "移除背景", text: "文字", overlay: "貼圖", export: "導出", convert: "轉換",
                undo: "復原", redo: "重做", reset: "重置",
                cropImage: "裁剪圖片", dragHandles: "拖曳控制點以調整裁剪區域。", free: "自由", original: "原始比例", applyCrop: "應用裁剪", lockAspect: "鎖定比例", fitMax: "最大範圍",
                resizeImage: "調整圖片大小", percentage: "百分比", width: "寬度", height: "高度", applyResize: "應用調整", estSize: "預估大小",
                removeBackground: "移除背景", magicWand: "魔棒工具", magicWandDesc: "點擊圖片移除顏色。", autoRemove: "自動移除", outlineOnly: "輪廓", tolerance: "容差", done: "完成",
                addText: "添加文字", textInput: "輸入文字", textColor: "顏色", textSize: "大小", applyText: "應用文字",
                addOverlay: "添加圖片", uploadOverlay: "上傳圖片", overlaySize: "大小", applyOverlay: "應用貼圖", changeImage: "更換圖片",
                videoToGif: "影片轉 GIF", gifDuration: "時長 (秒)", createGif: "製作 GIF", generating: "生成中...", videoFrame: "影片畫格", captureFrame: "擷取畫格",
                exportImage: "導出 / 轉換", fileName: "檔案名稱", format: "格式", quality: "品質", downloadImage: "下載檔案",
                imageCropped: "圖片已裁剪！", imageResized: "已調整大小！", bgRemoved: "背景已移除！", textAdded: "文字已添加！", overlayAdded: "貼圖已添加！", imageDownloaded: "已下載！"
            }
        };

        const UNITS = { px: { label: 'px', factor: 1 }, in: { label: 'in', factor: 96 }, cm: { label: 'cm', factor: 37.795 }, mm: { label: 'mm', factor: 3.7795 } };
        let activeUnit = 'px';

        /**
         * INITIALIZATION
         */
        window.onload = () => {
            lucide.createIcons();
            updateUI();
        };

        function t(key) {
            return TRANSLATIONS[state.lang][key] || key;
        }

        function updateUI() {
            // Update Text
            document.querySelectorAll('[data-t]').forEach(el => {
                el.innerText = t(el.getAttribute('data-t'));
            });
            
            // Landing vs Editor
            const hasMedia = state.imageSrc || state.videoSrc;
            document.getElementById('landing-page').classList.toggle('hidden', hasMedia);
            document.getElementById('editor-page').classList.toggle('hidden', !hasMedia);

            if (hasMedia) {
                renderHeader();
                renderToolbar();
                renderCanvasArea();
                renderSettingsPanel();
            } else {
                // Update landing text
                document.getElementById('landing-title').innerText = t('appTitle');
                document.getElementById('landing-subtitle').innerText = t('subtitle');
                document.getElementById('landing-upload-title').innerText = t('uploadTitle');
                document.getElementById('landing-upload-desc').innerText = t('uploadDesc');
                document.getElementById('lang-btn-text').innerText = state.lang === 'en' ? 'English' : '繁體中文';
            }
            lucide.createIcons();
        }

        /**
         * CORE ACTIONS
         */
        function handleUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);
            state.export.name = file.name.split('.')[0];

            if (file.type.startsWith('video/')) {
                state.videoSrc = url;
                state.imageSrc = null;
                state.history = [];
                state.historyIndex = -1;
                state.activeTool = null;
                // Wait for video metadata
                const video = document.getElementById('main-video');
                video.onloadedmetadata = () => {
                    state.currentDims = { w: video.videoWidth, h: video.videoHeight };
                    fitImageToScreen();
                    updateUI();
                };
            } else {
                const img = new Image();
                img.onload = () => {
                    state.imageSrc = url;
                    state.videoSrc = null;
                    state.currentDims = { w: img.width, h: img.height };
                    state.resize.width = img.width;
                    state.resize.height = img.height;
                    
                    // Init History
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width; canvas.height = img.height;
                    canvas.getContext('2d').drawImage(img, 0, 0);
                    const dataUrl = canvas.toDataURL();
                    
                    state.history = [dataUrl];
                    state.historyIndex = 0;
                    state.imageSrc = dataUrl; // Use dataURL for editing
                    
                    fitImageToScreen();
                    updateUI();
                };
                img.src = url;
            }
        }

        function addToHistory(newSrc) {
            state.history = state.history.slice(0, state.historyIndex + 1);
            state.history.push(newSrc);
            state.historyIndex++;
            state.imageSrc = newSrc;
            state.videoSrc = null; // Switching to image mode implies video is gone or frame captured
            updateUI();
        }

        function handleUndo() {
            if (state.historyIndex > 0) {
                state.historyIndex--;
                state.imageSrc = state.history[state.historyIndex];
                resetTools();
                updateUI();
            }
        }

        function handleRedo() {
            if (state.historyIndex < state.history.length - 1) {
                state.historyIndex++;
                state.imageSrc = state.history[state.historyIndex];
                resetTools();
                updateUI();
            }
        }

        function resetApp() {
            state.imageSrc = null;
            state.videoSrc = null;
            state.history = [];
            state.activeTool = null;
            updateUI();
        }

        function resetTools() {
            state.activeTool = null;
            state.crop.rect = null;
            state.overlay.src = null;
            updateUI();
        }

        function setActiveTool(tool) {
            state.activeTool = tool;
            
            // Init tool states
            if (tool === 'crop') {
                state.crop.rect = { x: 0.1, y: 0.1, w: 0.8, h: 0.8 };
                state.crop.lockAspect = false;
            }
            if (tool === 'resize') {
                state.resize = { width: state.currentDims.w, height: state.currentDims.h, maintainAspect: true, scale: 100 };
            }
            
            updateUI();
        }

        /**
         * RENDERING UI PARTS
         */
        function renderHeader() {
            document.getElementById('header-title').innerText = t('appTitle');
            document.getElementById('header-lang-text').innerText = state.lang === 'en' ? 'EN/中' : '中/EN';
            document.getElementById('font-size-label').innerText = state.fontSize;
            document.getElementById('zoom-level').innerText = Math.round(state.zoom * 100) + '%';
            
            const undoBtn = document.getElementById('btn-undo');
            const redoBtn = document.getElementById('btn-redo');
            
            if (state.videoSrc) {
                document.getElementById('history-controls').classList.add('hidden');
            } else {
                document.getElementById('history-controls').classList.remove('hidden');
                undoBtn.disabled = state.historyIndex <= 0;
                undoBtn.className = `flex items-center gap-2 px-3 py-1.5 rounded-lg text-[0.875em] font-medium transition-colors ${state.historyIndex > 0 ? 'hover:bg-slate-100 text-slate-700' : 'text-slate-300 cursor-not-allowed'}`;
                
                redoBtn.disabled = state.historyIndex >= state.history.length - 1;
                redoBtn.className = `flex items-center gap-2 px-3 py-1.5 rounded-lg text-[0.875em] font-medium transition-colors ${state.historyIndex < state.history.length - 1 ? 'hover:bg-slate-100 text-slate-700' : 'text-slate-300 cursor-not-allowed'}`;
            }
        }

        function renderToolbar() {
            const toolbar = document.getElementById('toolbar');
            let html = '';
            
            const btnClass = (active) => `w-14 h-14 rounded-xl flex flex-col items-center justify-center gap-1 transition-all duration-200 ${active ? 'bg-violet-600 text-white shadow-lg shadow-violet-200 scale-105' : 'text-slate-500 hover:bg-slate-100 hover:text-slate-800'}`;
            
            if (state.videoSrc) {
                html += `<button class="${btnClass(true)}" onclick=""><i data-lucide="file-video" class="w-6 h-6"></i><span class="text-[0.65em] font-medium">Video</span></button>`;
                html += `<button class="${btnClass(state.activeTool === 'gif')}" onclick="setActiveTool('gif')"><i data-lucide="refresh-cw" class="w-6 h-6"></i><span class="text-[0.65em] font-medium">GIF</span></button>`;
            } else {
                const tools = [
                    { id: 'crop', icon: 'crop', label: 'crop' },
                    { id: 'resize', icon: 'maximize-2', label: 'resize' },
                    { id: 'bgremove', icon: 'eraser', label: 'removeBg' },
                    { sep: true },
                    { id: 'text', icon: 'type', label: 'text' },
                    { id: 'overlay', icon: 'image', label: 'overlay' }
                ];

                tools.forEach(tool => {
                    if (tool.sep) {
                        html += `<div class="w-8 h-px bg-slate-200 my-1"></div>`;
                    } else {
                        html += `<button class="${btnClass(state.activeTool === tool.id)}" onclick="setActiveTool('${tool.id}')">
                            <i data-lucide="${tool.icon}" class="w-6 h-6"></i>
                            <span class="text-[0.65em] font-medium">${t(tool.label)}</span>
                        </button>`;
                    }
                });

                html += `<div class="flex-1"></div>`;
                html += `<button onclick="setActiveTool('export')" class="w-14 h-14 mb-4 rounded-xl flex flex-col items-center justify-center gap-1 transition-all duration-300 shadow-lg hover:shadow-xl hover:-translate-y-1 ${state.activeTool === 'export' ? 'bg-emerald-600 text-white ring-2 ring-emerald-200 ring-offset-2' : 'bg-gradient-to-br from-slate-800 to-slate-900 text-white hover:from-slate-700 hover:to-slate-800'}">
                    <i data-lucide="download" class="w-6 h-6"></i>
                    <span class="text-[0.65em] font-bold">${t(state.activeTool === 'export' ? 'export' : 'convert')}</span>
                </button>`;
            }
            
            toolbar.innerHTML = html;
        }

        function renderCanvasArea() {
            const wrapper = document.getElementById('canvas-wrapper');
            wrapper.style.transform = `scale(${state.zoom})`;
            
            const canvas = document.getElementById('main-canvas');
            const video = document.getElementById('main-video');
            const overlayLayer = document.getElementById('overlay-layer');
            
            // Clear overlays
            overlayLayer.innerHTML = '';
            // Reset pointer events
            canvas.classList.remove('cursor-crosshair');

            if (state.videoSrc) {
                canvas.classList.add('hidden');
                video.classList.remove('hidden');
                video.src = state.videoSrc;
                // Ensure dimensions match
                // We rely on onloadedmetadata for initial setup
            } else {
                video.classList.add('hidden');
                canvas.classList.remove('hidden');
                
                // Draw Image
                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.onload = () => {
                    if (canvas.width !== img.width || canvas.height !== img.height) {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        state.currentDims = { w: img.width, h: img.height };
                    }
                    ctx.clearRect(0,0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = state.imageSrc;

                // Render Overlays based on tool
                if (state.activeTool === 'crop' && state.crop.rect) {
                    renderCropOverlay(overlayLayer);
                } else if (state.activeTool === 'text') {
                    renderTextOverlay(overlayLayer);
                } else if (state.activeTool === 'overlay' && state.overlay.src) {
                    renderImageOverlay(overlayLayer);
                } else if (state.activeTool === 'bgremove') {
                    canvas.classList.add('cursor-crosshair');
                    canvas.onclick = handleCanvasClick;
                } else {
                    canvas.onclick = null;
                }
            }
        }

        function renderCropOverlay(container) {
            const { x, y, w, h } = state.crop.rect;
            const el = document.createElement('div');
            el.className = 'absolute shadow-[0_0_0_9999px_rgba(0,0,0,0.5)] cursor-move flex items-center justify-center group pointer-events-auto';
            el.style.left = (x * 100) + '%';
            el.style.top = (y * 100) + '%';
            el.style.width = (w * 100) + '%';
            el.style.height = (h * 100) + '%';
            el.style.outline = '2px solid white';
            
            // Grid
            el.innerHTML = `
                <div class="absolute inset-0 flex flex-col justify-between opacity-50 pointer-events-none"><div class="w-full h-px bg-white/50 mt-[33%]"></div><div class="w-full h-px bg-white/50 mb-[33%]"></div></div>
                <div class="absolute inset-0 flex justify-between opacity-50 pointer-events-none"><div class="h-full w-px bg-white/50 ml-[33%]"></div><div class="h-full w-px bg-white/50 mr-[33%]"></div></div>
                <div class="resize-handle top-0 left-0 cursor-nw-resize" onmousedown="startDrag(event, 'nw')"></div>
                <div class="resize-handle top-0 right-0 cursor-ne-resize" onmousedown="startDrag(event, 'ne')"></div>
                <div class="resize-handle bottom-0 left-0 cursor-sw-resize" onmousedown="startDrag(event, 'sw')"></div>
                <div class="resize-handle bottom-0 right-0 cursor-se-resize" onmousedown="startDrag(event, 'se')"></div>
            `;
            el.onmousedown = (e) => { if(e.target === el) startDrag(e, 'move'); };
            container.appendChild(el);
        }

        function renderTextOverlay(container) {
            const el = document.createElement('div');
            const { x, y, text, color, size } = state.text;
            // Font size calc relative to canvas width
            const fs = (size / 1000) * state.currentDims.w;
            
            el.style.position = 'absolute';
            el.style.left = (x * 100) + '%';
            el.style.top = (y * 100) + '%';
            el.style.transform = 'translate(-50%, -50%)';
            el.style.cursor = 'move';
            el.style.color = color;
            el.style.fontSize = fs + 'px';
            el.style.lineHeight = '1';
            el.style.fontWeight = 'bold';
            el.style.textShadow = '0 2px 4px rgba(0,0,0,0.5)';
            el.style.whiteSpace = 'nowrap';
            el.style.border = '1px dashed rgba(255,255,255,0.5)';
            el.style.pointerEvents = 'auto';
            el.innerText = text;
            
            el.onmousedown = (e) => startDragElement(e, 'text');
            container.appendChild(el);
        }

        function renderImageOverlay(container) {
            const el = document.createElement('div');
            const { x, y, scale, src } = state.overlay;
            
            el.style.position = 'absolute';
            el.style.left = (x * 100) + '%';
            el.style.top = (y * 100) + '%';
            el.style.transform = 'translate(-50%, -50%)';
            el.style.cursor = 'move';
            el.style.pointerEvents = 'auto';
            el.className = 'group border border-dashed border-transparent hover:border-violet-500';
            
            const img = document.createElement('img');
            img.src = src;
            img.style.width = (scale * state.currentDims.w) + 'px';
            img.style.pointerEvents = 'none';
            img.className = 'shadow-xl';
            
            el.appendChild(img);
            el.onmousedown = (e) => startDragElement(e, 'overlay');
            container.appendChild(el);
        }

        function renderSettingsPanel() {
            const panel = document.getElementById('settings-panel');
            const tool = state.activeTool;
            
            if (!tool) {
                panel.classList.add('hidden');
                return;
            }
            panel.classList.remove('hidden');
            
            let html = `
                <div class="flex items-center justify-between pb-4 border-b border-slate-100 mb-6">
                    <div class="flex items-center gap-2 text-slate-800 font-semibold">
                        <i data-lucide="${getToolIcon(tool)}" class="w-4 h-4"></i> <span>${t(getToolLabel(tool))}</span>
                    </div>
                    <button onclick="resetTools()" class="text-slate-400 hover:text-slate-600"><i data-lucide="x" class="w-5 h-5"></i></button>
                </div>
            `;

            // Tool Specific Content
            if (tool === 'crop') {
                html += `
                    <div class="space-y-6">
                        <div class="grid grid-cols-3 gap-2">
                            ${aspectBtn('Free', 'free', !state.crop.lockAspect)}
                            ${aspectBtn('Original', 'original', state.crop.lockAspect)}
                            ${ratioBtn('1:1', 1, 1)} ${ratioBtn('16:9', 16, 9)} ${ratioBtn('9:16', 9, 16)} ${ratioBtn('4:3', 4, 3)}
                            <button onclick="setFixedCrop(1920, 600)" class="py-2 px-1 rounded-md text-[0.75em] font-medium border border-slate-200 text-slate-600 hover:border-slate-300">1920x600</button>
                            <button onclick="setFixedCrop(800, 600)" class="py-2 px-1 rounded-md text-[0.75em] font-medium border border-slate-200 text-slate-600 hover:border-slate-300">800x600</button>
                        </div>
                        <div class="flex items-center justify-between">
                            <label class="flex items-center gap-2 text-[0.875em] text-slate-600">
                                <input type="checkbox" ${state.crop.lockAspect ? 'checked' : ''} onchange="toggleLockAspect(this.checked)" class="rounded text-violet-600">
                                ${t('lockAspect')}
                            </label>
                            ${state.crop.lockAspect ? `<button onclick="handleFitMax()" class="text-[0.75em] bg-violet-50 text-violet-700 px-2 py-1 rounded hover:bg-violet-100 flex items-center gap-1"><i data-lucide="maximize" class="w-3 h-3"></i> ${t('fitMax')}</button>` : ''}
                        </div>
                        <button onclick="applyCrop()" class="w-full py-2.5 bg-violet-600 text-white rounded-lg text-[0.9em] font-semibold hover:bg-violet-700 flex items-center justify-center gap-2"><i data-lucide="check" class="w-4 h-4"></i> ${t('applyCrop')}</button>
                    </div>
                `;
            } else if (tool === 'resize') {
                html += `
                    <div class="space-y-4">
                        <div>
                            <label class="block text-[0.75em] font-semibold text-slate-500 uppercase mb-1.5">${t('percentage')}</label>
                            <div class="flex items-center gap-3">
                                <input type="range" min="1" max="200" value="${state.resize.scale}" oninput="handleResizeChange('scale', this.value)" class="w-full">
                                <span class="text-[0.875em] font-medium w-12 text-right">${state.resize.scale}%</span>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-[0.75em] font-semibold text-slate-500 uppercase mb-1.5">${t('width')} (px)</label>
                                <input type="number" value="${state.resize.width}" onchange="handleResizeChange('width', this.value)" class="w-full px-3 py-2 bg-slate-50 border border-slate-200 rounded-md text-[0.875em]">
                            </div>
                            <div>
                                <label class="block text-[0.75em] font-semibold text-slate-500 uppercase mb-1.5">${t('height')} (px)</label>
                                <input type="number" value="${state.resize.height}" onchange="handleResizeChange('height', this.value)" class="w-full px-3 py-2 bg-slate-50 border border-slate-200 rounded-md text-[0.875em]">
                            </div>
                        </div>
                        <label class="flex items-center gap-2 text-[0.875em] text-slate-600">
                            <input type="checkbox" ${state.resize.maintainAspect ? 'checked' : ''} onchange="toggleResizeAspect(this.checked)" class="rounded text-violet-600"> ${t('lockAspect')}
                        </label>
                        <div class="bg-slate-50 p-3 rounded border border-slate-100 flex justify-between items-center">
                            <span class="text-[0.75em] font-semibold text-slate-500 uppercase">${t('estSize')}</span>
                            <span class="text-[0.875em] font-bold text-slate-700" id="resize-est-size">...</span>
                        </div>
                        <button onclick="applyResize()" class="w-full py-2.5 bg-violet-600 text-white rounded-lg text-[0.9em] font-semibold hover:bg-violet-700">${t('applyResize')}</button>
                    </div>
                `;
                calculateFileSize('resize');
            } else if (tool === 'bgremove') {
                html += `
                    <div class="space-y-6">
                        <div class="p-4 bg-violet-50 rounded-lg border border-violet-100">
                            <p class="text-[0.875em] text-violet-800 font-medium mb-1">${t('magicWand')}</p>
                            <p class="text-[0.75em] text-violet-600">${t('magicWandDesc')}</p>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <button onclick="handleAutoRemove()" class="py-2 bg-white border border-slate-200 rounded-md text-[0.8em] font-medium text-slate-700 hover:bg-slate-50 flex items-center justify-center gap-2"><i data-lucide="wand-2" class="w-3 h-3"></i> ${t('autoRemove')}</button>
                            <button onclick="handleOutline()" class="py-2 bg-white border border-slate-200 rounded-md text-[0.8em] font-medium text-slate-700 hover:bg-slate-50 flex items-center justify-center gap-2"><i data-lucide="scan-line" class="w-3 h-3"></i> ${t('outlineOnly')}</button>
                        </div>
                        <div>
                            <label class="block text-[0.75em] font-semibold text-slate-500 uppercase mb-1.5">${t('tolerance')}</label>
                            <div class="flex items-center gap-3">
                                <input type="range" min="1" max="100" value="${state.bgRemove.tolerance}" oninput="state.bgRemove.tolerance = parseInt(this.value); this.nextElementSibling.innerText = this.value" class="w-full">
                                <span class="text-[0.875em] font-medium w-8 text-right">${state.bgRemove.tolerance}</span>
                            </div>
                        </div>
                        <button onclick="applyBgRemoval()" class="w-full py-2.5 bg-violet-600 text-white rounded-lg text-[0.9em] font-semibold hover:bg-violet-700">${t('done')}</button>
                    </div>
                `;
            } else if (tool === 'text') {
                html += `
                    <div class="space-y-6">
                        <div>
                            <label class="block text-[0.75em] font-semibold text-slate-500 uppercase mb-1.5">${t('textInput')}</label>
                            <textarea rows="3" oninput="updateTextConfig('text', this.value)" class="w-full px-3 py-2 bg-slate-50 border border-slate-200 rounded-md text-[0.875em] focus:outline-none focus:ring-2 focus:ring-violet-500">${state.text.text}</textarea>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-[0.75em] font-semibold text-slate-500 uppercase mb-1.5">${t('textColor')}</label>
                                <input type="color" value="${state.text.color}" oninput="updateTextConfig('color', this.value)" class="w-full h-10 p-1 rounded cursor-pointer">
                            </div>
                            <div>
                                <label class="block text-[0.75em] font-semibold text-slate-500 uppercase mb-1.5">${t('textSize')}</label>
                                <input type="number" value="${state.text.size}" oninput="updateTextConfig('size', parseInt(this.value))" class="w-full px-3 py-2 bg-slate-50 border border-slate-200 rounded-md text-[0.875em]">
                            </div>
                        </div>
                        <button onclick="applyText()" class="w-full py-2.5 bg-violet-600 text-white rounded-lg text-[0.9em] font-semibold hover:bg-violet-700">${t('applyText')}</button>
                    </div>
                `;
            } else if (tool === 'overlay') {
                html += `<div class="space-y-6">`;
                if (!state.overlay.src) {
                    html += `
                        <div onclick="document.getElementById('overlay-upload').click()" class="border-2 border-dashed border-slate-300 rounded-lg p-6 flex flex-col items-center justify-center text-center hover:bg-slate-50 hover:border-violet-400 transition-colors cursor-pointer">
                            <i data-lucide="upload" class="w-6 h-6 text-slate-400 mb-2"></i>
                            <span class="text-[0.875em] font-medium text-slate-600">${t('uploadOverlay')}</span>
                        </div>
                    `;
                } else {
                    html += `
                        <div>
                            <label class="block text-[0.75em] font-semibold text-slate-500 uppercase mb-1.5">${t('overlaySize')}</label>
                            <input type="range" min="0.1" max="1.5" step="0.05" value="${state.overlay.scale}" oninput="updateOverlayScale(this.value)" class="w-full">
                        </div>
                        <div class="flex gap-2">
                            <button onclick="state.overlay.src = null; renderCanvasArea(); renderSettingsPanel()" class="flex-1 py-2 border border-slate-300 rounded text-slate-600 hover:bg-slate-50 text-[0.875em]">${t('changeImage')}</button>
                        </div>
                        <button onclick="applyOverlay()" class="w-full py-2.5 bg-violet-600 text-white rounded-lg text-[0.9em] font-semibold hover:bg-violet-700">${t('applyOverlay')}</button>
                    `;
                }
                html += `</div>`;
            } else if (tool === 'gif') {
                html += `
                    <div class="space-y-6">
                        <div class="p-4 bg-violet-50 rounded-lg border border-violet-100">
                            <p class="text-[0.875em] text-violet-800 font-medium mb-1">GIF Maker</p>
                            <p class="text-[0.75em] text-violet-600">Captures the first few seconds of your video.</p>
                        </div>
                        <div>
                            <label class="block text-[0.75em] font-semibold text-slate-500 uppercase mb-1.5">${t('gifDuration')}</label>
                            <input type="range" min="1" max="10" value="${state.gif.duration}" oninput="state.gif.duration = parseInt(this.value); this.nextElementSibling.innerText = this.value + 's'" class="w-full">
                            <span class="text-[0.875em] font-medium w-full text-right block mt-1">${state.gif.duration}s</span>
                        </div>
                        <button onclick="handleCreateGif()" class="w-full py-2.5 bg-violet-600 text-white rounded-lg text-[0.9em] font-semibold hover:bg-violet-700">${state.gif.generating ? t('generating') : t('createGif')}</button>
                        <div class="w-full h-px bg-slate-200 my-2"></div>
                        <p class="text-[0.875em] text-slate-500 font-medium">${t('videoFrame')}</p>
                        <button onclick="captureVideoFrame()" class="w-full py-2.5 bg-white border border-slate-300 rounded-lg text-[0.9em] font-medium text-slate-700 hover:bg-slate-50 flex items-center justify-center gap-2"><i data-lucide="scan-line" class="w-4 h-4"></i> ${t('captureFrame')}</button>
                    </div>
                `;
            } else if (tool === 'export') {
                html += `
                    <div class="space-y-6">
                        <div>
                            <label class="block text-[0.75em] font-semibold text-slate-500 uppercase mb-1.5">${t('fileName')}</label>
                            <input type="text" value="${state.export.name}" oninput="state.export.name = this.value" class="w-full px-3 py-2 bg-slate-50 border border-slate-200 rounded-md text-[0.875em]">
                        </div>
                        <div>
                            <label class="block text-[0.75em] font-semibold text-slate-500 uppercase mb-1.5">${t('format')}</label>
                            <div class="grid grid-cols-2 gap-2">
                                ${formatBtn('image/jpeg', 'JPG')} ${formatBtn('image/png', 'PNG')} 
                                ${formatBtn('image/webp', 'WEBP')} ${formatBtn('image/svg+xml', 'SVG')}
                            </div>
                        </div>
                        ${state.export.format !== 'image/png' && state.export.format !== 'image/svg+xml' ? `
                        <div>
                            <label class="block text-[0.75em] font-semibold text-slate-500 uppercase mb-1.5">${t('quality')}</label>
                            <div class="flex items-center gap-3">
                                <input type="range" min="0" max="1" step="0.1" value="${state.export.quality}" oninput="state.export.quality = parseFloat(this.value); this.nextElementSibling.innerText = Math.round(this.value * 100) + '%'; calculateFileSize('export')" class="w-full">
                                <span class="text-[0.875em] font-medium w-8 text-right">${Math.round(state.export.quality * 100)}%</span>
                            </div>
                        </div>
                        ` : ''}
                        <div class="bg-slate-50 p-3 rounded border border-slate-100 flex justify-between items-center">
                            <span class="text-[0.75em] font-semibold text-slate-500 uppercase">${t('estSize')}</span>
                            <span class="text-[0.875em] font-bold text-slate-700" id="export-est-size">...</span>
                        </div>
                        <button onclick="handleDownload()" class="w-full py-2.5 bg-violet-600 text-white rounded-lg text-[0.9em] font-semibold hover:bg-violet-700">${t('downloadImage')}</button>
                    </div>
                `;
                calculateFileSize('export');
            }

            panel.innerHTML = html;
            lucide.createIcons();
        }

        /** Helper to render buttons in settings */
        function aspectBtn(label, mode, active) {
            const click = mode === 'free' ? `setCropRatio(null)` : (mode === 'original' ? `setCropRatio('original')` : '');
            return `<button onclick="${click}" class="py-2 px-3 rounded-md text-[0.75em] font-medium border transition-colors ${active ? 'border-violet-200 bg-violet-50 text-violet-700' : 'border-slate-200 text-slate-600 hover:border-slate-300'}">${t(label.toLowerCase())}</button>`;
        }
        function ratioBtn(label, w, h) {
            return `<button onclick="setCropRatio(${w},${h})" class="py-2 px-3 rounded-md text-[0.75em] font-medium border transition-colors border-slate-200 text-slate-600 hover:border-slate-300">${label}</button>`;
        }
        function formatBtn(mime, label) {
            const active = state.export.format === mime;
            return `<button onclick="state.export.format = '${mime}'; renderSettingsPanel();" class="px-3 py-2 text-[0.75em] font-medium rounded-md border ${active ? 'bg-violet-600 text-white border-violet-600' : 'bg-white text-slate-600 border-slate-200 hover:bg-slate-50'}">${label}</button>`;
        }
        function getToolIcon(id) {
            const map = { crop: 'crop', resize: 'maximize-2', bgremove: 'eraser', text: 'type', overlay: 'image', gif: 'refresh-cw', export: 'download' };
            return map[id];
        }
        function getToolLabel(id) {
            if(id === 'export') return 'exportImage';
            if(id === 'bgremove') return 'removeBackground';
            if(id === 'crop') return 'cropImage';
            if(id === 'resize') return 'resizeImage';
            if(id === 'text') return 'addText';
            if(id === 'overlay') return 'addOverlay';
            if(id === 'gif') return 'videoToGif';
            return id;
        }

        /**
         * INTERACTION LOGIC
         */
        
        // Font Size
        function toggleFontSize() {
            const map = { small: 'normal', normal: 'large', large: 'small' };
            state.fontSize = map[state.fontSize];
            document.body.className = document.body.className.replace(/text-size-\w+/, `text-size-${state.fontSize}`);
            updateUI();
        }

        // Lang
        function toggleLang() {
            state.lang = state.lang === 'en' ? 'zh' : 'en';
            updateUI();
        }

        // Zoom
        function adjustZoom(delta) {
            state.zoom = Math.min(Math.max(0.05, state.zoom + delta), 5);
            renderCanvasArea();
            renderHeader();
        }
        function handleScrollZoom(e) {
            if(!state.imageSrc && !state.videoSrc) return;
            e.preventDefault();
            adjustZoom(e.deltaY * -0.001);
        }
        function fitImageToScreen() {
            const container = document.getElementById('canvas-container');
            const padding = 80;
            const availW = container.clientWidth - padding;
            const availH = container.clientHeight - padding;
            const scaleW = availW / state.currentDims.w;
            const scaleH = availH / state.currentDims.h;
            state.zoom = Math.min(scaleW, scaleH, 1);
            renderCanvasArea();
            renderHeader();
        }

        // Crop Logic
        function setCropRatio(w, h) {
            if (w === null) { state.crop.lockAspect = false; state.crop.rect = { x: 0.1, y: 0.1, w: 0.8, h: 0.8 }; }
            else if (w === 'original') { state.crop.lockAspect = true; state.crop.rect = { x: 0.1, y: 0.1, w: 0.8, h: 0.8 }; }
            else {
                const currentAspect = state.currentDims.w / state.currentDims.h;
                const targetAspect = w / h;
                let newW = 0.6;
                let newH = newW * (currentAspect / targetAspect);
                if (newH > 0.8) { newH = 0.6; newW = newH * (targetAspect / currentAspect); }
                state.crop.rect = { x: (1-newW)/2, y: (1-newH)/2, w: newW, h: newH };
                state.crop.lockAspect = true;
            }
            renderCanvasArea();
            renderSettingsPanel();
        }
        function setFixedCrop(w, h) {
            const aspect = w/h;
            let pctW = w / state.currentDims.w;
            let pctH = h / state.currentDims.h;
            if (pctW > 1 || pctH > 1) {
                const imgAspect = state.currentDims.w / state.currentDims.h;
                if (aspect > imgAspect) { pctW = 1.0; pctH = (state.currentDims.w / aspect) / state.currentDims.h; }
                else { pctH = 1.0; pctW = (state.currentDims.h * aspect) / state.currentDims.w; }
            }
            state.crop.rect = { x: (1-pctW)/2, y: (1-pctH)/2, w: pctW, h: pctH };
            state.crop.lockAspect = true;
            renderCanvasArea();
            renderSettingsPanel();
        }
        function toggleLockAspect(checked) { state.crop.lockAspect = checked; renderSettingsPanel(); }
        function handleFitMax() {
            if (!state.crop.rect) return;
            const pxW = state.crop.rect.w * state.currentDims.w;
            const pxH = state.crop.rect.h * state.currentDims.h;
            const aspect = pxW/pxH;
            const imgAspect = state.currentDims.w / state.currentDims.h;
            let newW, newH;
            if (aspect > imgAspect) { newW = 1.0; const hPx = state.currentDims.w / aspect; newH = hPx / state.currentDims.h; }
            else { newH = 1.0; const wPx = state.currentDims.h * aspect; newW = wPx / state.currentDims.w; }
            state.crop.rect = { x: (1-newW)/2, y: (1-newH)/2, w: newW, h: newH };
            renderCanvasArea();
        }
        function applyCrop() {
            const canvas = document.getElementById('main-canvas');
            const { x, y, w, h } = state.crop.rect;
            const sx = x * canvas.width;
            const sy = y * canvas.height;
            const sw = w * canvas.width;
            const sh = h * canvas.height;
            
            const newCanvas = document.createElement('canvas');
            newCanvas.width = sw; newCanvas.height = sh;
            newCanvas.getContext('2d').drawImage(canvas, sx, sy, sw, sh, 0, 0, sw, sh);
            
            addToHistory(newCanvas.toDataURL());
            resetTools();
            showNotification(t('imageCropped'));
        }

        // Dragging Logic (Unified)
        let dragInfo = null;
        function startDrag(e, type) {
            e.preventDefault(); e.stopPropagation();
            const { x, y, w, h } = state.crop.rect;
            const canvas = document.getElementById('main-canvas');
            let aspect = 1;
            if(state.crop.rect.h > 0) {
                const wPx = w * canvas.width; const hPx = h * canvas.height;
                aspect = wPx / hPx;
            }
            dragInfo = { type, startX: e.clientX, startY: e.clientY, startRect: { ...state.crop.rect }, aspect, mode: 'crop' };
            document.addEventListener('mousemove', onDragMove);
            document.addEventListener('mouseup', onDragEnd);
        }
        function startDragElement(e, mode) {
            e.preventDefault(); e.stopPropagation();
            const startX = mode === 'text' ? state.text.x : state.overlay.x;
            const startY = mode === 'text' ? state.text.y : state.overlay.y;
            dragInfo = { type: 'move', startX: e.clientX, startY: e.clientY, initialPos: { x: startX, y: startY }, mode };
            document.addEventListener('mousemove', onDragMove);
            document.addEventListener('mouseup', onDragEnd);
        }
        function onDragMove(e) {
            if (!dragInfo) return;
            const canvas = document.getElementById('main-canvas');
            const rect = canvas.getBoundingClientRect();
            
            if (dragInfo.mode === 'crop') {
                // Crop Logic (Ported from React)
                const scaleX = canvas.width / rect.width; 
                const scaleY = canvas.height / rect.height;
                const dx = (e.clientX - dragInfo.startX) * scaleX; 
                const dy = (e.clientY - dragInfo.startY) * scaleY;
                const dPctX = dx / canvas.width; 
                const dPctY = dy / canvas.height;
                
                let newRect = { ...dragInfo.startRect };
                const type = dragInfo.type;

                if (type === 'move') {
                    newRect.x = Math.max(0, Math.min(1 - newRect.w, newRect.x + dPctX));
                    newRect.y = Math.max(0, Math.min(1 - newRect.h, newRect.y + dPctY));
                } else {
                    // Resizing
                    if (type.includes('w')) { const maxD = newRect.x; const safeD = Math.max(-maxD, Math.min(newRect.w - 0.05, dPctX)); newRect.x += safeD; newRect.w -= safeD; }
                    else if (type.includes('e')) { const maxD = 1 - (newRect.x + newRect.w); const safeD = Math.min(maxD, Math.max(-(newRect.w - 0.05), dPctX)); newRect.w += safeD; }
                    if (type.includes('n')) { const maxD = newRect.y; const safeD = Math.max(-maxD, Math.min(newRect.h - 0.05, dPctY)); newRect.y += safeD; newRect.h -= safeD; }
                    else if (type.includes('s')) { const maxD = 1 - (newRect.y + newRect.h); const safeD = Math.min(maxD, Math.max(-(newRect.h - 0.05), dPctY)); newRect.h += safeD; }
                    
                    if (state.crop.lockAspect) {
                        const wPx = newRect.w * canvas.width; const hPx = wPx / dragInfo.aspect; const newH = hPx / canvas.height;
                        if (newRect.y + newH > 1 && type.includes('s')) {
                             const maxH = 1 - newRect.y; const maxW = (maxH * canvas.height * dragInfo.aspect) / canvas.width; newRect.h = maxH; newRect.w = maxW;
                        } else newRect.h = newH;
                    }
                }
                state.crop.rect = newRect;
                renderCanvasArea();
            } else {
                // Element Dragging (Text/Overlay)
                const dx = (e.clientX - dragInfo.startX) / rect.width;
                const dy = (e.clientY - dragInfo.startY) / rect.height;
                const newX = dragInfo.initialPos.x + dx;
                const newY = dragInfo.initialPos.y + dy;
                
                if (dragInfo.mode === 'text') { state.text.x = newX; state.text.y = newY; }
                else { state.overlay.x = newX; state.overlay.y = newY; }
                
                renderCanvasArea();
            }
        }
        function onDragEnd() {
            dragInfo = null;
            document.removeEventListener('mousemove', onDragMove);
            document.removeEventListener('mouseup', onDragEnd);
        }

        // Resize Logic
        function handleResizeChange(field, val) {
            const aspect = state.currentDims.w / state.currentDims.h;
            if (field === 'scale') {
                state.resize.scale = parseInt(val);
                state.resize.width = Math.round(state.currentDims.w * (val / 100));
                state.resize.height = Math.round(state.currentDims.h * (val / 100));
            } else if (field === 'width') {
                state.resize.width = parseInt(val);
                if (state.resize.maintainAspect) {
                    state.resize.height = Math.round(val / aspect);
                    state.resize.scale = Math.round((val / state.currentDims.w) * 100);
                }
            } else if (field === 'height') {
                state.resize.height = parseInt(val);
                if (state.resize.maintainAspect) {
                    state.resize.width = Math.round(val * aspect);
                    state.resize.scale = Math.round((state.resize.width / state.currentDims.w) * 100);
                }
            }
            renderSettingsPanel(); // Re-render to update inputs
        }
        function toggleResizeAspect(checked) { state.resize.maintainAspect = checked; renderSettingsPanel(); }
        function applyResize() {
            const canvas = document.createElement('canvas');
            canvas.width = state.resize.width; canvas.height = state.resize.height;
            const ctx = canvas.getContext('2d'); const img = new Image();
            img.onload = () => {
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                addToHistory(canvas.toDataURL()); resetTools(); showNotification(t('imageResized'));
            };
            img.src = state.imageSrc;
        }

        // BG Remove
        function handleCanvasClick(e) {
            const canvas = document.getElementById('main-canvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            removeColorAt(x, y);
        }
        function removeColorAt(startX, startY) {
            const canvas = document.getElementById('main-canvas');
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const idx = (Math.floor(startY) * canvas.width + Math.floor(startX)) * 4;
            const [tR, tG, tB] = [data[idx], data[idx+1], data[idx+2]];
            const tol = state.bgRemove.tolerance;
            
            for (let i = 0; i < data.length; i += 4) {
                const diff = Math.sqrt(((data[i]-tR)**2) + ((data[i+1]-tG)**2) + ((data[i+2]-tB)**2));
                if (diff < tol * 3) data[i+3] = 0;
            }
            ctx.putImageData(imageData, 0, 0);
        }
        function handleAutoRemove() {
            const canvas = document.getElementById('main-canvas');
            const w = canvas.width; const h = canvas.height;
            [[0,0], [w-1,0], [0,h-1], [w-1,h-1]].forEach(p => removeColorAt(p[0], p[1]));
            applyBgRemoval();
        }
        function handleOutline() {
            // Simple outline filter (Sobel approximation)
            const canvas = document.getElementById('main-canvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width; const h = canvas.height;
            const imgData = ctx.getImageData(0, 0, w, h);
            const d = imgData.data;
            const output = ctx.createImageData(w, h);
            const od = output.data;
            
            const getP = (x, y) => { if(x<0||y<0||x>=w||y>=h) return 0; const i=(y*w+x)*4; return (d[i]+d[i+1]+d[i+2])/3; };
            for(let y=0; y<h; y++) {
                for(let x=0; x<w; x++) {
                    const gx = -getP(x-1,y-1)+getP(x+1,y-1)-2*getP(x-1,y)+2*getP(x+1,y)-getP(x-1,y+1)+getP(x+1,y+1);
                    const gy = -getP(x-1,y-1)-2*getP(x,y-1)-getP(x+1,y-1)+getP(x-1,y+1)+2*getP(x,y+1)+getP(x+1,y+1);
                    const mag = 255 - Math.sqrt(gx*gx + gy*gy);
                    const i = (y*w+x)*4;
                    od[i]=mag; od[i+1]=mag; od[i+2]=mag; od[i+3]=255;
                }
            }
            ctx.putImageData(output, 0, 0);
            applyBgRemoval();
        }
        function applyBgRemoval() {
            addToHistory(document.getElementById('main-canvas').toDataURL());
            resetTools(); showNotification(t('bgRemoved'));
        }

        // Text & Overlay
        function updateTextConfig(key, val) { state.text[key] = val; renderCanvasArea(); }
        function applyText() {
            const canvas = document.getElementById('main-canvas');
            const ctx = canvas.getContext('2d');
            const { text, color, size, x, y } = state.text;
            ctx.fillStyle = color;
            ctx.font = `bold ${(size/1000)*canvas.width}px sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, x*canvas.width, y*canvas.height);
            addToHistory(canvas.toDataURL()); resetTools(); showNotification(t('textAdded'));
        }
        function handleOverlayFile(e) {
            const file = e.target.files[0];
            if(file) {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    state.overlay.src = evt.target.result;
                    renderCanvasArea(); renderSettingsPanel();
                };
                reader.readAsDataURL(file);
            }
        }
        function updateOverlayScale(val) { state.overlay.scale = parseFloat(val); renderCanvasArea(); }
        function applyOverlay() {
            const canvas = document.getElementById('main-canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            img.onload = () => {
                const aspect = img.width / img.height;
                const targetW = state.overlay.scale * canvas.width;
                const targetH = targetW / aspect;
                const x = (state.overlay.x * canvas.width) - (targetW/2);
                const y = (state.overlay.y * canvas.height) - (targetH/2);
                ctx.drawImage(img, x, y, targetW, targetH);
                addToHistory(canvas.toDataURL()); resetTools(); showNotification(t('overlayAdded'));
            };
            img.src = state.overlay.src;
        }

        // GIF
        function handleCreateGif() {
            if(!gifshot) return;
            state.gif.generating = true; renderSettingsPanel();
            const video = document.getElementById('main-video');
            gifshot.createGIF({
                video: [state.videoSrc],
                gifWidth: 300,
                gifHeight: 300 * (video.videoHeight / video.videoWidth),
                interval: 0.1, numFrames: state.gif.duration * 10
            }, (obj) => {
                state.gif.generating = false; renderSettingsPanel();
                if(!obj.error) {
                    const a = document.createElement('a'); a.href = obj.image; a.download = `${state.export.name}.gif`; a.click();
                    showNotification(t('imageDownloaded'));
                }
            });
        }
        function captureVideoFrame() {
            const video = document.getElementById('main-video');
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth; canvas.height = video.videoHeight;
            canvas.getContext('2d').drawImage(video, 0, 0);
            const dataUrl = canvas.toDataURL();
            
            state.videoSrc = null;
            state.imageSrc = dataUrl;
            state.history = [dataUrl];
            state.historyIndex = 0;
            state.currentDims = { w: canvas.width, h: canvas.height };
            state.resize.width = canvas.width; state.resize.height = canvas.height;
            updateUI();
        }

        // Export / File Size
        function calculateFileSize(mode) {
            const canvas = document.getElementById('main-canvas');
            if(!canvas) return;
            
            const targetId = mode === 'resize' ? 'resize-est-size' : 'export-est-size';
            const el = document.getElementById(targetId);
            if(!el) return;
            el.innerText = '...';

            setTimeout(() => {
                let tempCanvas = canvas;
                if (mode === 'resize') {
                    tempCanvas = document.createElement('canvas');
                    tempCanvas.width = state.resize.width; tempCanvas.height = state.resize.height;
                    tempCanvas.getContext('2d').drawImage(canvas, 0, 0, tempCanvas.width, tempCanvas.height);
                }
                
                const fmt = state.export.format;
                if (fmt === 'image/svg+xml') {
                    // Estimate
                    const data = tempCanvas.toDataURL('image/png');
                    el.innerText = formatBytes(data.length);
                } else {
                    tempCanvas.toBlob(blob => {
                        el.innerText = formatBytes(blob ? blob.size : 0);
                    }, fmt, state.export.quality);
                }
            }, 200);
        }

        function handleDownload() {
            const canvas = document.getElementById('main-canvas');
            const link = document.createElement('a');
            let ext = state.export.format.split('/')[1];
            if(ext.includes('svg')) ext = 'svg';
            link.download = `${state.export.name}.${ext}`;
            
            if (state.export.format === 'image/jpeg') {
                const temp = document.createElement('canvas');
                temp.width = canvas.width; temp.height = canvas.height;
                const ctx = temp.getContext('2d');
                ctx.fillStyle = '#FFF'; ctx.fillRect(0,0,temp.width, temp.height);
                ctx.drawImage(canvas, 0, 0);
                link.href = temp.toDataURL('image/jpeg', state.export.quality);
            } else if (state.export.format === 'image/svg+xml') {
                const data = canvas.toDataURL('image/png');
                const content = `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}"><image href="${data}" width="${canvas.width}" height="${canvas.height}"/></svg>`;
                link.href = URL.createObjectURL(new Blob([content], {type: 'image/svg+xml'}));
            } else {
                link.href = canvas.toDataURL(state.export.format, state.export.quality);
            }
            link.click();
            showNotification(t('imageDownloaded'));
        }

        // Utils
        function showNotification(msg) {
            const el = document.getElementById('notification');
            el.innerText = msg;
            el.classList.remove('hidden', 'opacity-0');
            setTimeout(() => { el.classList.add('opacity-0'); setTimeout(() => el.classList.add('hidden'), 300); }, 2000);
        }
        function formatBytes(bytes, decimals = 2) {
            if (!+bytes) return '0 Bytes';
            const k = 1024; const i = Math.floor(Math.log(bytes) / Math.log(k));
            return `${parseFloat((bytes / Math.pow(k, i)).toFixed(decimals))} ${['Bytes', 'KB', 'MB', 'GB'][i]}`;
        }

    </script>
</body>
</html>
